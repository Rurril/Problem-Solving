# ë°±ì¤€ 2042 - êµ¬ê°„ í•© êµ¬í•˜ê¸°

## ì ‘ê·¼

ì£¼ì–´ì§€ëŠ” ìˆ˜ì˜ ê°œìˆ˜ì™€ ì¿¼ë¦¬ë¬¸ì´ ë§ê¸° ë•Œë¬¸ì— ê¸°ì¡´ì— êµ¬í•˜ë˜ ë°©ì‹ìœ¼ë¡œ(DP) êµ¬ê°„í•©ì„ ì—°ì†í•´ì„œ êµ¬í•˜ë‹¤ë³´ë©´ ì‹œê°„ì´ˆê³¼ê°€ ë‚œë‹¤.

ê·¸ë ‡ê¸° ë•Œë¬¸ì— êµ¬ê°„í•©ì„ êµ¬í•  ë•Œ, ë³€ê²½ì´ ìì£¼ ì¼ì–´ë‚œë‹¤ë©´ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬(Segment Tree) í˜¹ì€ íœìœ… íŠ¸ë¦¬(Binary Indexed Tree)ë¥¼ ì´ìš©í•´ì„œ í’€ì–´ì•¼ í•œë‹¤.

> ì¼ë‹¨ ë‘ ê°œ ë‹¤ ëª°ëê¸°ì— ì´ë²ˆ ë¬¸ì œë¥¼ í’€ë©´ì„œ ê³µë¶€ë¥¼ í–ˆë‹¤.

---
## í’€ì´

### ì£¼ì–´ì§€ëŠ” ê°’ìœ¼ë¡œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ ìƒì„±


```java
long[] arr = new long[N];
for(int i=0; i<N; i++)
    arr[i] = Long.parseLong(br.readLine());

SegmentTree segmentTree = new SegmentTree(arr, N);
```

ì£¼ì–´ì§€ëŠ” ê°’ì„ ë°°ì—´ì— ë„£ì–´ì„œ SegmentTree í´ë˜ìŠ¤ì˜ ì¸ìë¡œ ë„£ì–´ì£¼ì—ˆë‹¤. (Nì€ ì¸ìì˜ ê°œìˆ˜)


### ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì˜ êµ¬í˜„

```java
private static class SegmentTree{
        private long[] segmentArr;

        private SegmentTree(long[] arr, int n){
            int height = (int) Math.ceil(Math.log(n) / Math.log(2)); // íŠ¸ë¦¬ì˜ ë†’ì´ë¥¼ êµ¬í•œë‹¤.
            int segmentSize = (int) Math.pow(2, height) * 2; // í¬ê¸°ëŠ” 2^height -1 ë§Œí¼ í•„ìš”í•˜ë‹¤.
            segmentArr = new long[segmentSize];

            init(arr, 0, n-1, 1);
        }

        // nodeë¥¼ rootë¡œ í•˜ëŠ” ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì´ˆê¸°í™”í•˜ê³ , ì´ êµ¬ê°„ì˜ ìµœì†Œì¹˜ë¥¼ ë°˜í™˜í•œë‹¤.
        private long init(long[] arr, int left, int right, int node){

            if(left == right)
                return segmentArr[node] = arr[left];

            int mid = (left + right)/2;

            return segmentArr[node] = init(arr, left, mid, node*2) + init(arr, mid+1, right, node * 2 + 1);
        }
}
```

ì¸ìì— ë¹„ë¡€í•´ì„œ í•„ìš”í•œ í¬ê¸°ë§Œí¼ë§Œ ë°°ì—´ì— í• ë‹¹í•´ì„œ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ ìƒì„±í•œë‹¤. 

ê·¸ë¦¬ê³  init ë©”ì†Œë“œë¥¼ ì´ìš©í•´ì„œ arr ë°°ì—´ì— ë„£ì€ ì´ˆê¸°ê°’ì„ segmentArrì— ì•Œë§ê²Œ ë„£ëŠ”ë‹¤. 


### ì£¼ì–´ì§€ëŠ” ìœ„ì¹˜ì˜ ê°’ ìµœì‹ í™”(Update)

```java
private long update(int index, long newValue, int node, int nodeLeft, int nodeRight){

    // Node êµ¬ê°„ì— í¬í•¨ë˜ì§€ ì•ŠëŠ” ê²½ìš°
    if(index < nodeLeft || index > nodeRight) return segmentArr[node];

    // Node êµ¬ê°„ì— í¬í•¨ë˜ëŠ” ê²½ìš° : Leaf ë…¸ë“œì¸ ê²½ìš°
    if(nodeLeft == nodeRight) return segmentArr[node] = newValue;

    int mid = (nodeLeft + nodeRight)/2;

    return segmentArr[node] = update(index, newValue, node * 2, nodeLeft, mid) + update(index, newValue, (node * 2) + 1, mid + 1, nodeRight);

}
```

ìƒˆë¡­ê²Œ ë°”ë€ŒëŠ” ì§€ì ì˜ ê°’ì„ ë°”ê¾¸ê³  ê·¸ ê°’ì„ ì°¸ì¡°í•˜ëŠ” ëª¨ë“  segmentArrì˜ ë°°ì—´ ê°’ë“¤ì„ ì—…ë°ì´íŠ¸ í•´ì¤€ë‹¤. 

ì‹œê°„ ë³µì¡ë„ê°€ ë†’ì´ë§Œí¼ìœ¼ë¡œ ì¤„ì–´ë“ ë‹¤. 


### êµ¬ê°„í•© êµ¬í•˜ê¸°

```java

private long query(int left, int right, int node, int nodeLeft, int nodeRight){

    // ë‘ êµ¬ê°„ì´ ê³‚ì¹˜ì§€ ì•ŠëŠ” ê²½ìš°
    if(left > nodeRight || right < nodeLeft)return 0;

    // ë…¸ë“œ êµ¬ê°„ì´ ì™„ì „íˆ ì†í•˜ëŠ” ê²½ìš°
    if(left <= nodeLeft && right >= nodeRight) return segmentArr[node];

    int mid = (nodeLeft + nodeRight)/2;

    return query(left, right, node*2, nodeLeft, mid) + query(left, right, (node * 2)+1, mid + 1, nodeRight);
}
```

ì¬ê·€ì  ë°©ì‹ìœ¼ë¡œ ë†’ì´ë§Œí¼ í™•ì¸í•œë‹¤.

ëª¨ë“  ìœ„ì¹˜ë¥¼ ì°¾ìœ¼ë©´ì„œ left to rightê¹Œì§€ ë¶€ë¶„í•©ì„ êµ¬í•˜ë„ë¡ í•œë‹¤. 

--- 
## ğŸ”¥ ì‹œí–‰ì°©ì˜¤

1. êµ¬ê°„í•©ì„ êµ¬í•˜ëŠ” DPë°©ì‹ìœ¼ë¡œ ì ‘ê·¼ì„ í•˜ë‹¤ê°€, ì£¼ì–´ì§€ëŠ” ìˆ˜ë“¤ê³¼ ì¿¼ë¦¬ë¬¸ì˜ ìˆ˜ë¥¼ ë³´ë‹ˆ ì‹œê°„ë‚´ë¡œ ì ˆëŒ€ë¡œ í’€ ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ì•Œê³ ì„œ ë‚´ê°€ ëª¨ë¥´ëŠ” ë°©ì‹ì˜ ì•Œê³ ë¦¬ì¦˜ í˜¹ì€ ë°ì´í„° êµ¬ì¡°ê°€ ìˆì„ ê²ƒì´ë¼ëŠ” ê²ƒì„ ì•Œì•˜ë‹¤.
2. ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ì™€ íœìœ… íŠ¸ë¦¬ì— ëŒ€í•´ì„œ ê³µë¶€ë¥¼ í•˜ê³ ì„œ í’€ê²Œ ë˜ì—ˆë‹¤.


## ğŸ¤­ ë¹„ìŠ·í•œ ë¬¸ì œ

ë°±ì¤€ ì˜¨ë¼ì¸ ì €ì§€
- 


## ğŸ’Œ ì°¸ê³  ìë£Œ

> [N2042_sub.java](https://github.com/Rurril/Problem-Solving/blob/Test/Problem-Solving/PS/SegmentTree/N2042_sub.java) : ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¡œ í‘¼ ê²ƒ

> [N2042.java](https://github.com/Rurril/Problem-Solving/blob/Test/Problem-Solving/PS/SegmentTree/N2042.java) : íœìœ… íŠ¸ë¦¬ë¡œ í‘¼ ê²ƒ 


