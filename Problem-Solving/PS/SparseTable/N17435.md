# 백준 17435 - 합성함수와 쿼리

## 접근

희소배열을 이용해서 푸는 기본 문제

희소배열을 모른다면, 일일히 한 단계씩 올라가면서 원하는 함수 값을 찾으려면 쿼리당 O(N)의 시간복잡도를 사용해서 전체 시간복잡도는 O(MN)이 되어 시간초과...

희소배열을 이용해서 단계를 logN으로 줄임으로써 전체 시간복잡도는 O(MlogN)이 되게 한다.

---
## 풀이

### 희소배열을 만들기

```java
private static void sparseTable(){

    for(int j=1;j<=19;j++){
        for(int i=1;i<=M;i++){
            table[i][j] = table[table[i][j-1]][j-1];
        }
    }
}
```

전에 구한 것을 이용하는 DP방식을 이용하여 

table[i][j] 는 i를 입력했을 때, 2^j번째 값을 나타내게 하였다.


### 원하는 값을 찾기



```java
private static int findValue(int n, int x){

    int k = 0;
    while (n >= 1) {
        if (n%2 == 1) {
            x = table[x][k];
        }
        n /= 2;
        k++;
    }

    return x;
}
```

10진수를 2진수로 만드는 방법을 이용해서 x에 원하는 값을 계속 담으면서 진행했다.

ex ) 11 = 1011(2) 인 것처럼.

원하는 값을 f11(2)라고 했다면

f8(f2(f1(2)))와 같이 구하는 것이다.

만약 이 풀이를 보고 이해하기 힘들다면, 직접 손으로 써가면서 왜 이런 방식이 적용이 되는지 이해하는 것을 추천한다.



--- 
## 🔥 시행착오

1. LCA - 최소 공통조상을 찾는 알고리즘에서 한 번 공부하고 넘어간 개념이라서 다시 접근하는 것은 어렵지 않았다.
2. 다만 알고 있는 거랑 직접 구하고 구현하는 거랑은 갭차이가 심했다. 이해를 했더라도 다시 논리대로 코드로 구현하는 것은 상당히 난이도가 높았다. (배열로 쓰려니까 더 힘든 듯)


## 🤭 비슷한 문제

백준 온라인 저지
- 


## 💌 참고 자료

[N17435.java](https://github.com/Rurril/Problem-Solving/blob/Test/Problem-Solving/PS/SparseTable/N17435.java)


