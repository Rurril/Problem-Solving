# ë°±ì¤€ 17135 - ìºìŠ¬ ë””íœìŠ¤

## ì ‘ê·¼

BFS ë°©ì‹ìœ¼ë¡œ í•´ê²°í•˜ì§€ë§Œ, ê²°êµ­ BFë°©ì‹ë„ ì‚¬ìš©í•˜ê²Œ í•˜ëŠ” ê·€ì°®ì€ ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œ

---
## í’€ì´

### ì‹œë®¬ë ˆì´ì…˜


```java
private static int simulation(int one, int two, int three){

    t_map = new int[N+1][M];
    int enemyCnt = 0;
    Archer[] archers = new Archer[3];
    archers[0] = new Archer(N, one);
    archers[1] = new Archer(N, two);
    archers[2] = new Archer(N, three);

    for(int i=0;i<N;i++){
        for(int j=0;j<M;j++){
            t_map[i][j] = map[i][j];
        }
    }

    for(int i=0;i<N;i++){
        enemyCnt += turn(archers);
    }
    return enemyCnt;
}
```

ê¶ìˆ˜ ì…‹ì˜ ì¢Œí‘œë¥¼ BF ë°©ì‹ìœ¼ë¡œ ë‹¤ ì„¤ì •í•˜ì—¬ ì£½ì¸ ì ì˜ ìˆ«ìë¥¼ ì²´í¬í•œë‹¤. 

### í„´ ì§„í–‰

```java
private static int turn(Archer[] archers){

    int enemyCnt = 0;
    boolean[] isDead = new boolean[3];
    for(int i=0;i<archers.length;i++){

        boolean flag = findEnemy(archers[i]);
        if(flag){
            isDead[i] = true;
        }
    }

    for(int i=0;i<3;i++){
        if(isDead[i]){
            int y = archers[i].enemyY;
            int x = archers[i].enemyX;
            if(t_map[y][x] == 1){
                t_map[y][x] = 0;
                enemyCnt++;
            }
        }
    }
    enemyMove();

    return enemyCnt;
}
```

ë§¤ í„´ë§ˆë‹¤, ê¶ìˆ˜ ì‚¬ì •ê±°ë¦¬ ì•ˆì— ìˆëŠ” ì ì„ ì°¾ì•„ì„œ ì£½ì´ê³  ì¹´ìš´íŒ…í•œë‹¤. ê·¸ë¦¬ê³  í•œì¹¸ì”© ì ë“¤ì„ ì›€ì§ì¸ë‹¤. 

### BFSë¡œ ì ì„ ì°¾ê¸° 

```java
private static boolean findEnemy(Archer archer){

    Queue<Node> q = new LinkedList<>();
    q.add(new Node(archer.y, archer.x));
    boolean[][] isVisited = new boolean[N+1][M];
    isVisited[archer.y][archer.x] = true;
    int dist = 0;
    while(!q.isEmpty()){

        dist++;
        if(dist > D)break;

        for(int size = q.size(); size >0; size--){
            Node current = q.poll();

            for(int i=0;i<3;i++){
                int ny = current.y + dy[i];
                int nx = current.x + dx[i];

                if(ny > N || ny < 0 || nx >= M || nx < 0 || isVisited[ny][nx])continue;
                isVisited[ny][nx] = true;

                if(t_map[ny][nx] == 1){
                    archer.enemyY = ny;
                    archer.enemyX = nx;
                    return true;
                }
                q.add(new Node(ny, nx));
            }
        }
    }
    return false;
}
```

ì ì„ ì°¾ëŠ” ë°©ì‹ì€ ê° ê¶ìˆ˜ë§ˆë‹¤ BFS ë°©ì‹ìœ¼ë¡œ ì°¾ë„ë¡ í•œë‹¤.


--- 
## ğŸ”¥ ì‹œí–‰ì°©ì˜¤

1. ì‹œí–‰ì°©ì˜¤ë¥¼ ê²ªì—ˆë‹¤ê¸° ë³´ë‹¤ëŠ”, ì„¤ì •í•  ì¡°ê±´ë“¤ì´ ë§ì€ ê·€ì°®ì€ ë¬¸ì œì˜€ë‹¤. 
2. ì™¼ìª½ì— ìˆëŠ” ì ì„ ìš°ì„ ì ìœ¼ë¡œ ì£½ì´ê³ , ê¶ìˆ˜ë“¤ì´ ê°™ì€ ì ì„ ì£½ì´ëŠ” ê²½ìš°ë„ í™•ì¸ì„ í•´ì£¼ì–´ì•¼ í•œë‹¤. 




## ğŸ¤­ ë¹„ìŠ·í•œ ë¬¸ì œ

ë°±ì¤€ ì˜¨ë¼ì¸ ì €ì§€
- 


## ğŸ’Œ ì°¸ê³  ìë£Œ

[N17135.java](https://github.com/Rurril/Problem-Solving/blob/Test/Problem-Solving/PS/Simulation/N17135.java)


